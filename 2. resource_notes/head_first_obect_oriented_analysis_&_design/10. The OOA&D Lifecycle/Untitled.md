"Feature List: Figure out what your app is supposed to do at a high level." (pg. 484)

"Use Case Diagrams: Nail down the big processes that your app performs, and any external forces that are involved." (pg. 484)

"Break Up the Problem: Break your application up into modules of functionality, and then decide on an order in which to tackle each of your modules." (pg. 484)

"Requirements: Figure out the individual requirements for each module, and make sure those fit in with the big picture." (pg. 484)

"Domain Analysis: Figure out how your use cases map to objects in your app, and make sure your customer is on the same page as you are." (pg. 485)

"Preliminary Design: Fill in details about your objects, define relationships between the objects, and apply principles and patterns." (pg. 485)

"Implementation: Write code, test it, and make sure it works. Do this for each behavior, each feature, each use case, each problem, until you're done." (pg. 485)

"Delivery: You're done! Release your software, submit your invoices, and get paid." (pg. 485)

"You'll spend most of your development time in the design and implementation phases." (pg. 485)

"Features and requirements are often used almost interchangeably. Most of the time though people say 'feature' when they're talking about BIG things that an application needs to do. So it might take several requirements to satisfy one feature. And since features are usually a little bigger-picture than requirements, it's a good idea to start any new project by writing out a feature list, like we've done with the RouteFinder." (pg. 494)

"The feature list isn't just a list of hard problems you have to solve- it's a list of all the things your application has to be able to do. So even if a feature seems easy or trivial, put it on your feature list anyway." (pg. 494)

"With a feature list in hand, you should have a good understanding of the things that your app needs to do. You probably even can begin to think about the structure of your application, although we'll spend a lot more time on that in just a bit." (pg. 495)

"Once you've got your feature list down, you should move on to use case diagrams. Those will help you connect what you app does to how it will be used- and that's what customers really are interested in." (pg. 495)

"Your feature lists are all about understanding what your software is supposed to do." (pg. 495)

"Your case diagrams let you start thinking about how your software will be used, without getting into a bunch of unnecessary details." (pg. 495)

"Use cases reflect usage, features reflect functionality." (pg. 499)

"When we're writing use cases, we're dealing with just the interactions between actors and a system. We're just talking about the ways that your system is used (which is where the term 'use case' came from)." (pg. 499)

"The features in your system reflect your system's functionality. Your system must do those things in order for the use cases to actually work, even though the functionality isn't always an explicit part of any particular use case." (pg. 499)

"A use case may depend upon a feature to function, but the feature may not actually be part of the steps in the use case itself." (pg. 499)

"You should be able to match up every feature to a use case in the system. Every feature in your system will be at least a part of addressing one or more use cases in your use case diagram. But that doesn't mean that the use case has to actually directly use that feature. Lots of times, a feature makes it possible for a use case to function without being directly used by the use case itself." (pg. 500)

"Both a use case and a feature are a requirement. Use cases are requirements for how people and things (actors) interact with your system, and features are requirements about things that your system must do. They're related, but they are not the same thing. Still, to implement a system's use cases, you're going to need the functionality in the system's features. That's why you should always be able to map your features to the use cases that they enable and are used by." (pg. 500)

"If you find a feature that can't match up to a use case directly, then you should take a hard look at the feature, and makes sure it really is a required part of the system. Your customers only interact with your system through the use cases. So if a feature doesn't at least indirectly make a use case possible, you're customer really isn't going to see a benefit. If you think you've got a feature that doesn't really affect how your system is used or performs, talk it over with the customer, but don't be afraid to cut something if its not going to improve your system." (pg. 500)

"The features in your system are what the system does, and are not always reflected in your use cases, which show how the system is used." (pg. 500)

"Features and use cases work together, but they are not the same thing." (pg. 500)

"Remember, you need to handle the system's functionality, but you also need to prove to the customer that your system works." (pg. 501)

"Once you've broken up your software into several individual pieces of functionality, you're ready to start iterating over each piece of functionality, until the application is complete." (pg. 503)

"At this point, we need to take our big-picture view of the system, from our use case diagram, and refine that into requirements that we can begin to tackle, one by one." (pg. 503)

"Then we can take care of that use case, and iterate again, working on the next use case." (pg. 503)

"You'll often have to do some extra work between breaking up the problem and writing your use cases." (pg. 504)

"If you get stuck writing a use case, there's nothing wrong with taking a step back, and examining the problem you're trying to solve a bit. Then, you can go back to your use case, and have a better change of getting it written correctly." (pg. 504)

"There are lots of decisions you have to make to solve any problem." (pg. 508)

"Validation is something that you should add to your use case if you left it out." (pg. 508)

Use Case reminds me of an algorithm. We run through the steps and check if it works. Use Case x Test Case. Running through a test case reminds me of running through an algorithm. Making sure the logic is sound.

"It's on to preliminary design. Using the candidate nouns and verbs you got from the use case, draw a class diagram. Use associations and any other UML notation you think will help make your design clear and understandable." (pg. 511)