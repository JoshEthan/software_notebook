"We have feature lists, individual modules to code, high-level views of what we need to build, the customer's vision, and even some design patterns to apply." (pg. 325)

"It's really not enough to just figure out the individual pieces of a big problem. You also need to know a little bit about how those pieces fit together, and which ones might be more important than others; that way, you'll know what you should work on first." (pg. 326)

"Architecture is you design structure, and highlights the most important parts of your app, and the relationships between those parts.-- Architecture helps us design the big systems. Our use case diagram was the start of the relationships, but it's still pretty unclear how all the modules interact." (pg. 326)

"Architecture is the organizational structure of a system, including its decomposition into parts, their connectivity, interaction mechanisms, and the guiding principles and decisions that you use in the design of a system." (pg. 326)

"Architecture takes a big chaotic mess and helps us turn it into a well-orded application." (pg. 327)

"We want to use all the information we have to create a nice, well-constructed application." (pg. 327)

"All the diagrams and patterns are used to build the customer exactly what they want, all within a flexible reusable design." (pg. 327)

"You write great software the same way, whether you're working on a small project, or a huge on. You can still apply the three steps we talked about." (pg. 328)

"The 3 steps apply to building great BIG software, too" (pg. 328)

"These three steps apply when you're working on really big applications, too. So we need to start with what the customer wants an app to do, before we get into details about the actual design of the app." (pg. 328)

"The first step is to make sure an application does what it's supposed to do. In small projects, we used a requirements list to write down functionality; in big projects, we've been using a feature list to figure those things out." (pg. 329)

"All of these features are about functionality... they focus on what the system has to do, not on what principles or patterns you use to build the system." (pg. 329)

"Even if we know to start by focusing on functionality, we still need to figure out which pieces are the most important. Those are the pieces we want to focus on first." (pg. 329)

"The things in your application that are really important are architecturally significant, and you should focus on them FIRST." (pg. 331)

"It's awfully hard to talk about the relationships between parts of a system if you don't have any of the parts themselves. To figure out how these modules interact, you'd need to have at least the basics of two modules in place first. So architecture isn't just about the relationship between parts of your app; it's also about figuring out which parts are the most important, so you can start building those parts first." (pg. 331)

"When figuring out if something is architecturally significant:
1. Is it part of the essence of the system?-- Is the feature really core to what a system actually is? Think about it this way: can you imagine the system without that feature? If not, then you've probably found a feature that is part of the essence of a system.
2. What the heck does it mean?-- If you're not sure what the description of a particular feature really means, it's probably pretty important that you pay attention to that feature. Anytime you're unsure about what something is, it could take lots of time, or create problems with the rest of the system. Spend time on these features early, rather than late.
3. How the heck do I do it?-- Another place to focus your attention early on is on features that seem really hard to implement, or are totally new programming tasks for you. If you have no idea how you're going to tackle a particular problem, you better spend some time up front looking at that feature, so it doesn't create lots problems down the road."  (pg. 332)

"The essence of a system is what it is at its most basic level. In other words, if you stripped away all the bells and whistles, all the 'neat' things that marketing threw  in, and all the cool ideas you had, what would the system really be about? That's the essence of a system."  (pg. 335)

"When you're looking at a feature, ask yourself: 'If this feature wasn't implemented, would the system still really be what it's supposed to be? If the answer is no, you've found yourself an 'essence feature'."  (pg. 335)

"Not knowing something isn't a bad requirement. It is a sign that you might need to get some additional requirements, or at least some clarification. In the early stages, you can leave some details out to get a basic sense of a system. But at this stage, it's time to fill in some of those details, and that's what the second Q of architecture is all about."  (pg. 335)

"Even if you've never written code specifically for a task before, it's just a few new details, really. But if you're new to threads, then that would be something you don't know how to do. Those are things to look out for: particularly hard tasks that you're unsure about how to handle."  (pg. 335)

"In a lot of cases, this all ends up just being a judgement call. But as long as you choose to start working on things that seem the most important to the system, you're going to get off to a good start. What you don't want to do is see some things that look familiar- perhaps you've solved the same problem in another project- and start there. Start with the core pieces of the system, and the things that look like they might be particularly hard, and you'll be on the road to success."  (pg. 335)

"The essence of a system is what that system is at its most basic level."  (pg. 335)

"Using the three Qs of architecture, we've started to add some order to all that confusion we started out with.-- Start with a mess, then focused on making the system do what it is supposed to do, finally, we've narrowed that down to just a few key features to focus on."  (pg. 336)

"The reason that these features are architecturally significant is that they all introduce RISK to your project. It doesn't matter which on you start with- as long as you are working towards reducing the RISKS in succeeding."  (pg. 338)

"Since we don't know what this means, it could be a ton of work, and that's a RISK in meeting schedules and deadlines. This is something we're not sure how to do, so there's RISK that we won't figure it out, or it will take a really long time. If the core features of the system aren't in place, there's a serious RISK that the customer won't like the system."  (pg. 338)

"The point here is to REDUCE RISK, not to argue over which key feature you should start with first. You can start with ANY of these, as long as you're focused on building what you're supposed to be building."  (pg. 338)

"You should still write use cases whenever possible. Scenarios are helpful for quick problems, and to find thee most common requirements. Remember, scenarios are only one path through a use case. If there are lots of alternate paths, you might miss some important requirements if you used just a scenario for your requirements."  (pg. 343)

"If you're just getting started, and a use case seems like it might be premature, just using scenario is a good way to get started." (pg. 343)

"Remember, when you're figuring out requirements, whether you're using a use case, a use case diagram, or a scenario, you're trying to make sure you are building just what the customer wants. Without good requirements, the risk is letting down or upsetting the customer by building the wrong thing." (pg. 343)

"During the requirement phase is when you're writing use cases, putting together a requirements list, and using lots of scenarios to chart out all the paths through a use case." (pg. 343)

"Sometimes you don't have a complete requirements list and a bunch of use cases, but you still need to get some basic work done to see how a system is going to work. â€¦using a scenario to get the basics of a module or piece of code down, so you can get the basic building blocks of your application in place." (pg. 343)

"Scenarios help in gathering requirements, in being sure your use cases are complete, but also in architecture, helping you reduce the chaos and confusion around what a particular module or piece of code does." (pg. 343)