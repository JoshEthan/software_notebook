"You solve big problems the same way you solve small problems." (pg. 280)

"It's all in how you look at the big problem." (pg. 281)

"The best way to look at a big problem is to see it as lots of individual pieces of functionality." (pg. 281)

"You can treat each of those pieces as an individual problem to solve, and apply the things you already know.-- Once you get one part of an application working like you want it to, then you can move on to another piece of functionality within the app." (pg. 281)

"You can solve a big problem by breaking it into lots of functional pieces, and then working on each of those pieces individually." (pg. 281)

"The BIG PROBLEM is really just a collection of functionalities, where each piece of functionality is really a smaller problem on its own." (pg. 281)

"By encapsulating what varies, you make your application more flexible, and easier to change.-- Using encapsulation helps with big problems, too. The more you encapsulate things, the easier it will be for you to break a large app up into different pieces of functionality." (pg. 282)

"Coding to an interface, rather than to an implementation, makes your software easier to extend.-- This is even more important in big apps. By coding to an interface, you reduce dependencies between different parts of your application... and 'loosely coupled' is always a good thing, remember?" (pg. 282)

"The best way to get good requirements is to understand what a system is supposed to do.-- If you know what each small piece of your app's functionality should do, then it's easy to combine those parts into a big app that does what it's supposed to do." (pg. 282)

"Analysis helps you ensure you system works in a real-world context.-- Analysis is even more important with large software... and in most cases, you start by analyzing individual pieces of functionality, and then analyzing the interaction of those pieces." (pg. 283)

"Great software is easy to change and extend, and does what the customer wants it to do.-- This sure doesn't change with bigger problems. In fact, the higher the cohesion of your app, the more independent each piece of functionality is, and the easier it is to work on those pieces one at a time." (pg. 283)

"Requirements and use cases are a good place to start, but what do we really know about the system so far?-- Starting out working on a system by building a requirements list and writing use cases is a great idea. You can figure out what a system is supposed to do, and just go down your list adding functionality bit by bit... solving lots of small problems to solve on really big problem." (pg. 286)

"We need a lot more information-- So now we've got to figure out what the system is supposed to do." (pg. 287)

"One way you can find out more about a system is to figure out what the system is like. In other words, are there some things that you do know about that the system functions or behaves like?-- This is called commonality... what things are similar?" (pg. 287)

"Another great way to find out what a system should do is to figure out what it's not like. This helps you determine what you don't need to worry about in your system.-- This is called variability... what things are different?" (pg. 287)

"A feature is just a high-level description of something a system needs to do. You usually get features from talking to your customers (or listening in on their conversations, like we just did on the last few pages.)" (pg. 290)

"A lot of times, you can take one feature, and come up with several different requirements that you can use to satisfy that feature. So figuring out a system's features is a great way to start to get a handle on your requirements." (pg. 290)

"Starting with features of a system is really helpful in big projects when you don't have tons of details, and just need to get a handle on where to start." (pg. 290)

"Get features from the customer, and then figure out the requirements you need to implement those features." (pg. 291)

"Here's a single feature we got from the customer. That single feature results in multiple different requirements." (pg. 291)

"Don't get hung up on the 'difference' between a feature and a requirement." (pg. 292)

"For some people, a feature is a requirement... Others think of features as higher-level than requirement..." (pg. 292)

"The main thing is that if you're stuck on where to get started, especially with a big project, you can gather features (or requirements!) to get a handle on the high-level things you know you'll need to take care of in the system you're building." (pg. 292)

I DON'T AGREE WITH INTERCHANGEABLE TERMS. IT CAUSES CONFUSION AND IS REDUNDANT.

"For some people, a feature is a 'big' thing that a system does. But to put that feature in place, there are lots of 'small' things that the system must do. All of these little things are considered requirements. So a single feature is satisfied by several requirements." (pg. 293)

"There are other ways to look at features and requirements. A lot of other people don't make such a distinction between a feature and a requirement." (pg. 293)

"There's no 'one right way' to think about features and requirements, especially if you don't want to waste time arguing over definitions with your programmer buddies." (pg. 293)

"Use cases don't always help you see the big picture.-- When you start to write use cases, you're really getting into a lot of detail about what the system should do. The problem is that can cause you to lose sight of the big picture." (pg. 294)

"So even though you could start writing use cases, that probably won't help you figure out exactly what you're trying to build, from the big-picture point of view. When you're working on a system, it's a good idea to defer details as long as you can... you won't get caught up in the little things when you should be working on the big things." (pg. 294)

"Always defer details as long as you can." (pg. 294)

"You still need to know what your system is supposed to do.. but you need a BIG-PICTURE view.-- Even though use cases might be a little too focused on the details for where we are in designing the system right now, you still need to have a good understanding of what your system needs to do. So you need a way to focus on the big picture, and figure out what your system should do, while still avoiding getting into too much detail." (pg. 295)

"Sometimes you need to know what a system does, but don't want to get into all the detail the use cases require. When you're in a situation like this, a use case diagram could be just what you need." (pg. 296)

"This stick figure is an actor. He acts on the system." (pg. 296)

"This big box represents the system. What's inside the box is the system; what's outside uses the system. So the box is the system boundary." (pg. 296)

"Each of these ovals represents a single use case in the system." (pg. 296)

"This use case diagram might not be the most detailed set of blueprints for a system, but it tells you everything the system needs to do, in a simple, easy-to-read format. Use cases are much more detail-oriented, and don't help you figure out the big picture like a good use case diagram does." (pg. 296)

"Use case diagrams are the blueprints for your system.-- Remember, our focus here is on the big picture. That use case diagram may seem sort of vague, but it does help you keep your eye on the fundamental things that your system must do. Without it, you could easily get so caught up in the details of how a designer creates a new game that you completely forget that they need to actually deploy that game." (pg. 297)

"With a use case diagram, you'll never forget about the big picture." (pg. 297)

"Use your feature list to make sure your use case diagram is complete.-- Once you have your features and a use case diagram, you can make sure you're building a system that will do everything it needs to. Take your use case diagram, and make sure that all the use cases you listed will cover all the features you got from the customer. Then you'll know that your diagram- the blueprints for your system- is complete, and you can start building the system." (pg. 297)

"An actor is actually any external entity (it doesn't have to be a person) that interacts with the system. If it's not part of the system but acts on the system, it's an actor." (pg. 299) 

"The box shows the boundaries of the system. So you have to code up everything inside the box, but you don't have to worry about the stuff outside the box. The actors are outside of the box because they use your system; they're not part of it." (pg. 299) 

"Each circle is a use case. That's part of why use case diagrams are great for getting a handle on the big picture: they can show you multiple use cases, and how all those use cases work together to do really big tasks. It also helps you avoid getting into details about a particular requirement too early." (pg. 299) 

"UML and use case diagrams do define ways to specify what kind of relationships exist between use cases. So you could say that one use case includes another, or that one use case extends another. That's what the `<<include>>` and `<<extend>>` keywords mean." (pg. 299) 

"However, it's easy to spend a lot of time arguing over whether a use case extends this use case, or includes that one instead of focusing on the bigger picture. You can use `<<>>`, but it's not that big of a deal, and those keywords should never distract form the overall design process." (pg. 299) 

"Use case diagrams are more about a general picture of the system than including lots of little details. If you're worrying too much about what to call a use case, or whether you should use a particular relationship between use cases, you've lost sight of the big picture. Use your use case diagrams to get a clear 10,000-foot view of your system, nothing more." (pg. 299) 

"Actors don't have to be people." (pg. 302) 

"Use a feature or requirement list to capture the BIG THINGS that your system needs to do." (pg. 305) 

"Once you've got your features and requirements mapped out, you need to get a basic idea of how the system is going to be put together. Use cases are often too detailed at this stage, so a use case diagram can help you see what a system is like at 10,000 feet... kind of like a blueprint for you application." (pg. 305)

"Draw a use case diagram to show what your system IS without getting into unnecessary detail." (pg. 305)

"Domain analysis lets you check you designs, and still speak the customer's language." (pg. 306)

"These"